// B. LCM строк

// ограничение по времени на тест2 секунды
// ограничение по памяти на тест256 мегабайт
// вводстандартный ввод
// выводстандартный вывод
// Давайте определим операцию умножения между строкой 𝑎 и положительным целым числом 𝑥: 𝑎⋅𝑥 — это строка, которая является результатом записи 𝑥 копий 𝑎 одна за другой. Например, «abc» ⋅ 2 = «abcabc», «a» ⋅ 5 = «aaaaa».

// Строка 𝑎 делится на другую строку 𝑏, если существует целое число 𝑥 такое, что 𝑏⋅𝑥=𝑎. Например, «abababab» делится на «ab», но не делится на «ababab» или «aa».

// LCM из двух строк 𝑠 и 𝑡 (определяется как 𝐿𝐶𝑀(𝑠,𝑡)) — это самая короткая непустая строка, которая делится как на 𝑠, так и на 𝑡.

// Вам даны две строки 𝑠 и 𝑡. Найдите 𝐿𝐶𝑀(𝑠,𝑡) или сообщите, что он не существует. Можно показать, что если 𝐿𝐶𝑀(𝑠,𝑡) существует, то он единственный.

// Входные данные
// Первая строка содержит одно целое число 𝑞 (1≤𝑞≤2000) — количество наборов входных данных.

// Каждый набор состоит из двух строк, содержащих строки 𝑠 и 𝑡 (1≤|𝑠|,|𝑡|≤20). Каждый символ в каждой из этих строк является либо 'a', либо 'b'.

// Выходные данные
// Для каждого набора входных данных выведите 𝐿𝐶𝑀(𝑠,𝑡), если он существует; в противном случае выведите -1. Можно показать, что если 𝐿𝐶𝑀(𝑠,𝑡) существует, то он единственный.

// Пример
// входные данные
// 3
// baba
// ba
// aa
// aaa
// aba
// ab
// выходные данные
// baba
// aaaaaa
// -1


#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>
#include <stack>
#include <deque>
#include <sstream>
#include <string>
 
 
using namespace std;
 
string operator*(const string& s, unsigned int n) {
    stringstream out;
    while (n--)
        out << s;
    return out.str();
}


int main(){
	int t;
	cin >> t;
	for (int i_t = 1; i_t <= t; ++i_t) {
	    string s, t;
		cin >> s >> t;
        string res;

        for(int i=1; i<=20; i++) {
            bool ex=false;
            for(int j=1; j<=20; j++) {
                if(s*i==t*j) {
                    res=s*i;
                    ex=true;
                    break;
                }
            }
            if(ex) break;
        }

        if(res.size()) {
        cout << res << endl;
        } else {
        cout << "-1" << endl;
        }
  }
  
  return 0;
}